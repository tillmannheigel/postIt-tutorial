\documentclass[10pt,a4paper]{article}
\usepackage[latin1]{inputenc}
 \usepackage[ngerman]{babel}
\usepackage[babel,german=quotes]{csquotes}
\usepackage{amsmath,amsfonts,amssymb}
\usepackage{graphicx,xcolor}
\usepackage{listings}
\lstset{language=Java}
\author{Tillmann Heigel}
\title{Tutorial einer PostIt - Anwendung}
\begin{document}

\section*{Tutorial: Post-It--Anwendung}

In diesem Tutorial werden wir lernen wie man mit der Programmiersprache Java und der in Java integrierten Bibliothek\footnote{Eine Programmbibliothek ist eine Sammlung von bereitgestellten Klassen und Funktionen, die einen bestimmten Zweck erfüllen. Im Falle von \lstinline[basicstyle=\ttfamily]{javax.swing.*} das Darstellen einer graphischen Oberfläche für eine Programm.} \lstinline[basicstyle=\ttfamily]{javax.swing.*} ein Fenster erstellt mit welchem man Text formatieren und darstellen  kann.

\section{Planung der GUI}

Als GUI (Abk. GUI von graphical user interface) wird die Benutzerschnittstelle eines computerprogramms bezeichnet, mit der ein Mensch mittels Eingabegerät-en (z.B. Maus oder Touchscreen) interagiert. Für ein Programm, das eine grafische Oberfläche bekommen soll, macht es Sinn sich zuallererst Gedanken darüber machen, was die Hauptfunktionen der Anwendung sind und wie diese auf einer graphischen Benutzeroberfläche dargestellt werden können. Die dabei entstehenden Skizzen nennt man auch \enquote{Mock-Ups}\footnote{siehe dazu http://de.wikipedia.org/wiki/Mock-up}. Aus den Mock-ups leitet man anschließend nicht-funktionalen Anforderungen, die das Aussehen der fertigen Anwendung beschreiben ab.

\subsection{Ein erstes Mock-up}

% Anspruch: 1/6
% Lerneffekt: 2/6

Für unser Programm, die Post-It--Anwendung steht ganz klar die Schreibfläche, also das eigentliche Post-It im Mittelpunkt. Damit die Anwender die Schreibfläche auch als Post-It erkennen, sollte sie im klassischen gelb dargestellt werden (siehe Abbildung). Darauf soll man später seine Notizen schreiben können.


\begin{figure}[h]
\begin{center}
\includegraphics{flaeche}
\caption{Unser erstes Mockup-Element. Das Post-It, eine gelbe Fläche. Wirklich großartig, aber sind wir jetzt schon fertig?}
\label{1}
\end{center}
\end{figure} 


Da man den Text später auch formatieren können soll, fehlt uns nun aber noch eine Werkzeugleiste, wie wir sie aus Programmen wie Word (Microsoft) oder Writer (Open-/LibreOffice) kennen. Wie üblich ordnen wir sie im oberen Bereich der Anwendung an, damit sie schnell gefunden werden kann. 

\begin{figure}[h]
\begin{center}
\includegraphics{flaeche_toolbar}
\caption{Unser Mockup-Element. Jetzt mit einem seperaten Bereich für die Werkzeugleiste.}
\label{2}
\end{center}
\end{figure} 

Exemplarisch bauen wir auch gleich die drei wichtigsten Buttons \enquote{B} (engl. bold = fett schreiben), \enquote{I} (engl. italic = kursiv schreiben) und \enquote{U} (engl. underlined = unterstrichen schreiben) sowie eine Dropdown-Element zum Auswählen der Schriftart ein, damit wir uns das ganze etwas besser vorstellen können.

\begin{figure}[h]
\begin{center}
\includegraphics{flaeche_toolbar_buttons_dropdown}
\caption{Unser Mockup-Element. So soll die Werkzeugleiste am Ende in etwa aussehen.}
\label{3}
\end{center}
\end{figure} 

Die Werkzeugleiste sieht schon ganz gut aus, was jetzt noch fehlt ist der letzte Schliff am Textbereich. Klar ist, dass wir viel Platz für die Kreativität der Schreibenden lassen müssen, aber evtl. gibt es noch die ein oder andere Information, die der computer besser weiß. Was könnte das sein? Wir könnten zum Beispiel rechts oben ein Datum einfügen. Außerdem wollen wir eine Überschrift haben, die \enquote{sticky} ist, d.h. sie soll immer sichtbar sein, auch wenn der Text evtl. gescrollt werden muss.

Große Firmen wie Apple oder Google haben in den vergangenen Jahren sehr viel Geld investiert, um herauszufinden, wie eine graphische Benutzerschnittstelle gestaltet sein muss, damit Menschen sie \textit{gerne} nutzen. Ein Ergebnis daraus war beispielsweise der Touchscreen des iPhones oder das skeuomorphe\footnote{Skeuomorphismus beschreibt die Strategie, sich im Software-Design an Gegenständen und Werkzeugen aus der realen Welt zu orientieren, um die Funktion von Programmen oder Systemen zu erklären.} Design des Betriebssystems iOS (das aber mittlerweile seit iOS 7 durch den sog. \enquote{Minimalismus} abgelöst wurde).

\paragraph{Anforderungen} Aus dem eben erstellten Mock-up können wir einen Teil der Anforderungen an die Anwendung ableiten, die wir hier noch einmal zusammenfassen:

\begin{itemize}
\item Die Graphische Oberfläche der Anwendung soll aus einem Fenster bestehen, das zwei Bereiche beinhaltet.
\item Der Bereich oben repräsentiert die Werkzeugleiste der Anwendung und nimmt etwa 1/6 bis 1/5 des Fensters ein. 
\item Der größere Bereich darunter rerpäsentiert einen Notizzettel. Er soll eine gelbe Farbe besitzen. Weiterhin soll man Text eingeben können und diesen unterschiedlich(!) formatieren können. 
\end{itemize}

\section{Implementierung mit javax.swing}

%Anspruch: 3/6
%Lerneffekt: 3/6

Die Programmbibliothek javax.swing (ab jetzt nur noch Swing genannt), ist eine Bibliothek, die im Java Developer Kit enthalten ist, die es relativ einfach ermöglicht Grafische Oberflächen mit Java code zu erzeugen. Neben Swing existieren noch einige weitere Bibliotheken, die Oberflächen erzeugen können, in diesem Beispiel möchten wir uns aber auf Swing beschränken.

Zunächst einmal müssen wir ein Fenster erzeugen, in welchem unsere Anwendung ihre Inhalte bereit stellt. Da wir später noch einige Anpassungen an der Klasse vornehmen wollen, erweitern wir die Klasse \lstinline[basicstyle=\ttfamily]{javax.swing.JFrame} und erstellen eine eigene Klasse NotesFrame. Achtung: Immer dort, wo bisher im code Punkte stehen, kommt später noch etwas hinzu:

\begin{lstlisting}[frame=single,keywordstyle=\color{blue}]
public class NotesFrame extends JFrame {
	
//...

}
\end{lstlisting}

Um den code sauber zu trennen, schreiben wir uns noch eine Hauptklasse, in der die Anwendung (und der soeben erstellte Frame) gestartet wird: 

\begin{lstlisting}[frame=single,keywordstyle=\color{blue}]
public class NotesMain{
	
	static int x = 420;
	static int y = 320;
	
	public static void main(String[] args) {
		//...
		NotesFrame frame = new NotesFrame(//...);
		frame.setSize(x, y);
		frame.setVisible(true);
	}
}
\end{lstlisting}

Nachdem wir jetzt eine Haupt-Klasse und eine Frame-Klasse haben, können wir uns um das Layout kümmern. Da wir im Mock-up schon relativ klar definiert haben, welche GUI-Bereiche es in der Anwendung gibt, müssen wir sie nun noch im code implementieren. Um uns die Arbeit etwas zu erleichtern, gibt es auch für diese Aufgabe Bibliotheken, die uns den code auf ein Minimum reduzieren lassen: Die \textit{Layout--Manager}.

\paragraph{Layout--Manager}

Normalerweise müsste man in GUIs pixelgenau festlegen, wo sich welches Element befindet und wie es sich verhält, wenn sich die Fenstergröße ändert. Die Layout--Manager unterstützen beim Entwickeln von GUIs, indem sie alle nötigen Berechnung für die Entwickler übernehmen und dabei bestimmte Strategien verfolgen. Jeder Layout--Manager verfolgt dabei eine eigene Strategie:

\begin{itemize}
\item \textbf{FlowLayout}: Alle Elemente werden nebeneinander abgelegt. Ist die Zeile voll, wird in der nächsten Zeile weiter gemacht.
\item \textbf{GridLayout}: Die Elemente werden in einem Gitter mit einer zuvor festgelegten Anzahl von Zeilen und Spalten abgelegt.
\item \textbf{BorderLayout}: Das BorderLayout ist das klassische Fensterlayout. Es gibt fünf Bereiche für Elemente: oben, unten, links, rechts und in der Mitte. 
\item \textbf{cardLayout}: Arbeitet wie ein Kartenstapel und kann Elemente ein- und ausblenden.
\item \textbf{GridBagLayout}: Ähnlich dem GridLayout, kann aber noch spezifischer angepasst werden.
\end{itemize}

An dieser Stelle ist noch festzuhalten, dass sich alle Layout-Manager beliebig schachteln lassen und so beliebig komplexe Layouts erstellt werden können. 

Für die Post-It--Anwendung entscheiden wir uns, da wir einen Bereich oben und einen Hauptbereich in der Mitte haben, für das BorderLayout.

\begin{figure}[h]
\begin{center}
\includegraphics[width=\textwidth]{BorderLayout}
\caption{Das BorderLayout und seine Positionsangaben}
\label{3}
\end{center}
\end{figure} 

Dafür erweitern wir unsere Klasse \lstinline[basicstyle=\ttfamily]{NotesFrame} um ein Feld \lstinline[basicstyle=\ttfamily]{mainPanel} und einen Konstruktor, der diesem den Borderlayout--LayoutManager zuweist. Das ganze funktioniert wie folgt:

\begin{lstlisting}[frame=single,keywordstyle=\color{blue}]
public class NotesFrame extends JFrame {
	
	JPanel mainPanel;

	public NotesFrame(){	
				
		this.mainPanel = new JPanel();
		this.mainPanel.setLayout(new BorderLayout());					
		this.getcontentPane().add(mainPanel);
		pack();		
		
		this.setDefaultcloseOperation(EXIT_ON_CLOSE);
	}
\end{lstlisting}

Im Konstruktor der Klasse erstellen wir zunächst ein neues Objekt vom Typ \lstinline[basicstyle=\ttfamily]{JPanel}. Mit der Methode \lstinline[basicstyle=\ttfamily]{setLayout(new BorderLayout())} wird dem soeben erstellen JPanel ein BorderLayout--Manager zugewiesen. Zuletzt wird das \lstinline[basicstyle=\ttfamily]{mainPanel} mit der Methode \lstinline[basicstyle=\ttfamily]{add(mainPanel)} dem \lstinline[basicstyle=\ttfamily]{contentPane}\footnote{contentPane ist ein container, dem alle Panel-Elemente hinzugefügt werden müssen, die angezeigt werden sollen.} zugewiesen.

Damit haben wir nun ein Fenster mit einem JPanel und einem LayoutManager. Damit sind die Grundlagen für die GUI geschaffen. Was nun noch fehlt, ist das Einbinden und Konfigurieren unserer Oberflächenelemente.

\subsection{Toolbar}

 JToolBar ist eine GUI-Komponente, mit welcher man Steuerelemente, wie z.B. Buttons o.Ä. anzeigen und bedienbar machen kann. Wir erstellen uns als in einem ersten Schritt ein JPanel, das selbst wiederum eine besitzt JToolbar, in der wir unsere Buttons (bold, italic, underlined) einfügen und Anpassungen vornehmen können. Passenderweise benennen wir das JPanel ToolbarPanel: 
 
 \begin{lstlisting}[frame=single,keywordstyle=\color{blue}]
public class ToolbarPanel extends JPanel {
	
	JToolBar toolbar;
	
	public ToolbarPanel(){
		
		toolbar = new JToolBar();
		this.add(toolbar);
		
	}
}
 \end{lstlisting}
 
 Damit haben wir schon das wichtigste geschafft. Unsere \lstinline[basicstyle=\ttfamily]{JToolBar} muss nun mit Leben gefüllt werden, um den Sinn Ihres Daseins zu erfüllen. Fangen wir damit an, vier Buttons hinzuzufügen:
 
  \begin{lstlisting}[frame=single,keywordstyle=\color{blue}]
 public class ToolbarPanel extends JPanel {
 	
 	JToolBar toolbar;
 	private JToggleButton boldButton = new JToggleButton();
 	private JToggleButton italicButton = new JToggleButton();
 	private JToggleButton underlineButton = new JToggleButton();
 	
 	public ToolbarPanel(){
 		
 		toolbar = new JToolBar();
 		this.setButtons();
 		this.add(toolbar);
 		
 	}
 	
 	private void setButtons(){
 	
 		toolbar.add(boldButton);
 		toolbar.add(italicButton);
 		toolbar.add(underlineButton);

 		boldButton.setIcon(new ImageIcon("src/img/font_bold_icon&32.png"));
 		italicButton.setIcon(new ImageIcon("src/img/font_italic_icon&32.png"));
 		underlineButton.setIcon(new ImageIcon("src/img/font_underline_icon&32.png"));
 	}
 	
 }
  \end{lstlisting}
  
Das Hinzufügen von Buttons funktioniert genauso, wie das Hinzufügen der \lstinline[basicstyle=\ttfamily]{JToolBar} zum \lstinline[basicstyle=\ttfamily]{JPanel}: Mit der Methode \lstinline[basicstyle=\ttfamily]{add(...)} wird es zu einer \enquote{Kindklassen} der \lstinline[basicstyle=\ttfamily]{JToolBar}. 

Im Beispiel nutzen wir übrigens drei \lstinline[basicstyle=\ttfamily]{JToggleButton}s. Im Gegensatz zu  \lstinline[basicstyle=\ttfamily]{JButton}s blieben diese gedrückt, nachdem man sie einmal angeklickt hat, wohingegen eine \lstinline[basicstyle=\ttfamily]{JButton}s einen einmaligen \textit{klick} auslösen und anschließend wieder den alten Zustand annehmen. Für unsere Anwendungsfälle ist der \lstinline[basicstyle=\ttfamily]{JToggleButton} daher für die Textformatierung besser geeignet. Wir erweitern die Methode \lstinline[basicstyle=\ttfamily]{setButtons} außerdem noch um weitere Methoden, welche Grafiken auf die Buttons setzen.  

Als weitere Funktion wollen wir es den Anwendern ermöglichen die Schriftart zu wechseln. Dafür müssen wir noch das DropDown-Menü aus dem Mock-up Implementieren. Das entsprechende Element in Swing heißt: \lstinline[basicstyle=\ttfamily]{JcomboBox}.

  \begin{lstlisting}[frame=single,keywordstyle=\color{blue}]
 public class ToolbarPanel extends JPanel {
 	
//...

 	private JComboBox<String> fontscomboBox;
 	
 	
 	public ToolbarPanel(){
 		
 		toolbar = new JToolBar();
 		this.setFontBox();
 		this.setButtons();
 		this.add(toolbar);
 		
 	}
 	
 	private void setFontBox(){
		fontsComboBox = new JComboBox<String>();		
		toolbar.add(fontscomboBox);		
 	}
 	
//...
 	
 }
  \end{lstlisting}

\subsection{Post-It}  
 
In den vorherigen Schritten haben wir zunächst eine Hauptklasse erstellt. Diese erstellt ein Fenster (\lstinline[basicstyle=\ttfamily]{JFrame}) mit der von uns abgeleiteten Klasse \lstinline[basicstyle=\ttfamily]{NotesFrame}. Im dritten Schritt haben wir die Toolbar (\lstinline[basicstyle=\ttfamily]{JToolBar}) erstellt und darin die Buttons (\lstinline[basicstyle=\ttfamily]{JToggleButtons}) und ein Dropdown-Menü (\lstinline[basicstyle=\ttfamily]{JcomboBox}) erstellt. Was nun noch fehlt, ist der Eingabebereich unserer Anwendung, sozusagen das Post-It. 

Um die zuvor aufgestellten Anforderungen bezüglich des Post-Its umzusetzen, müssen wir nun ein Swing-Objekt finden, dass die Eingabe von Text ermöglicht. Zur Auswahl stehen uns hier verschiedene Eingabefelder: \lstinline[basicstyle=\ttfamily]{JTextField}, \lstinline[basicstyle=\ttfamily]{JTextArea} oder das \lstinline[basicstyle=\ttfamily]{JTextPane}. Nach genauerer Betrachtung wird man aber feststellen, dass sich eigentlich für unseren Zweck nur eines eignet. \lstinline[basicstyle=\ttfamily]{JTextfield} ist lediglich ein einzeiliges Textfeld und fliegt damit raus.\lstinline[basicstyle=\ttfamily]{ JTextArea} ist mehrzeilig, lässt jedoch nur die Formatierung des gesamten Textes auf einmal zu. \lstinline[basicstyle=\ttfamily]{JTextPane} erfüllt schließlich die Anforderung, ist aber etwas komplizierter anzupassen.
  
Als letzten Schritt für die Entwicklung unserer GUI, müssen wir alles noch in unserer Fensterklasse NotesFrame zusammenfügen. Dies geschieht im Konstruktor der Klasse \lstinline[basicstyle=\ttfamily]{NotesFrame}.
  
  \begin{lstlisting}[frame=single,keywordstyle=\color{blue}]
  public class NotesFrame extends JFrame {
  	
  	JPanel mainPanel;
  	ToolbarPanel toolbar;
  	JTextPane textpane;
  
  	public NotesFrame(){	
  				
  		this.mainPanel = new JPanel();
  		toolbar = new ToolbarPanel();
  		textpane = new JtextPane();
  		
		mainPanel.add(toolbar ,BorderLayout.PAGE_START);
		mainPanel.add(textpane,BorderLayout.CENTER);
  		this.getcontentPane().add(mainPanel);
  		
  		pack();		
  		this.setDefaultcloseOperation(EXIT_ON_CLOSE);
  	}
  \end{lstlisting}
  

Versuchen wir das ganze Programm mal zu bauen und schauen wir uns das vorläufige Ergebnis doch mal genauer an:

\begin{figure}[h]
\begin{center}
\includegraphics[width=\textwidth]{fenster}
\caption{Das BorderLayout und seine Positionsangaben}
\label{3}
\end{center}
\end{figure} 

Das sieht unserem Mock--up schon sehr ähnlich. An dieser Stelle kann man jetzt noch versuchen, die Anordnung schöner zu gestalten oder vielleicht ein paar Anpassungen vorzunehmen, aber für unsere Zwecke in diesem Tutorial sollte das ausreichen. 

Wenn man probiert auf die Buttons zu klicken passiert allerdings nichts. Das liegt natürlich daran, dass wir bisher noch gar keine Anwendungslogik implementiert haben. Darum geht es im nächsten Kapitel
\newpage
\newpage
\section{Anwendungs--Logik}

%Anspruch: 5/6
%Lerneffekt: 6/6

Der \enquote{Rahmen} unserer Anwendung steht bereits und sieht auch schon ganz gut aus. Was aber noch fehlt, sind die Methoden, mit welchen wir unsere Toolbar funktionsfähig machen können.

\subsection{System--Schriftarten laden}

Der erste Schritt soll sein, in unserem Dropdown--Menu alle dem System bekannten Schriftarten anzuzeigen und für den Anwender auswählbar zu machen. Dafür wechseln wir zurück in die Klasse \lstinline[basicstyle=\ttfamily]{ToolbarPanel}. In der Methode \lstinline[basicstyle=\ttfamily]{setFontBox()} nutzen wir schon einen Konstruktor für unsere \lstinline[basicstyle=\ttfamily]{JComboBox}, allerdings ohne Parameter. Übergibt man allerdings ein Array von Objekten, dann werden diese in der Liste angezeigt. Wir erstellen uns daher ein String--Array mit den Namen \lstinline[basicstyle=\ttfamily]{fonts}.


  \begin{lstlisting}[frame=single,keywordstyle=\color{blue}]
 public class ToolbarPanel extends JPanel {
 	
//...
 	
 	private void setFontBox(){
		fontsComboBox = new JComboBox<String>(fonts);		
		toolbar.add(fontscomboBox);		
 	}
 	
//...

 }
  \end{lstlisting}

Da unser \lstinline[basicstyle=\ttfamily]{fonts}--Array noch leer ist, müssen wir eine Methode finden, mit welcher wir die System-Schriftarten laden können. Die Lösung des Problems bietet uns die Klasse \lstinline[basicstyle=\ttfamily]{java.awt.GraphicsEnvironment}. Diese Klasse stellt unter Anderem Methoden für den Zugriff auf die Schriftarten des Systems bereit. Dafür müssen wir uns zuerst mit der Factory--Methode \lstinline[basicstyle=\ttfamily]{getLocalGraphicsEnvironment()} ein GraphicsEnviroment--Objekt erstellen und können anschließend mit der Methode \lstinline[basicstyle=\ttfamily]{getAvailableFontFamilyNames()} auf alle dem System bekannten Schriftarten zugreifen. Wir nutzen hier speziell diese Methode, um Duplikate auszuschließen.

  \begin{lstlisting}[frame=single,keywordstyle=\color{blue}]
 public class ToolbarPanel extends JPanel {
 	
 //...
 	
 	private void setFontBox(){
 		GraphicsEnvironment enviroment = GraphicsEnvironment.getLocalGraphicsEnvironment();
 		fonts = enviroment.getAvailableFontFamilyNames();
		fontsComboBox = new JComboBox<String>(fonts);		
		toolbar.add(fontscomboBox);		
 	}
 	
//...
 	
 }
  \end{lstlisting}

Starten wir nun die Anwendung erneut, sehen wir eine Liste aller verfügbaren Schriftarten in unserem DropDown-Menü. Sehr gut! Was jetzt noch fehlt, sind Aktionen, die beim Klicken auf einen Button oder beim Auswählen einer Schriftart ausgeführt werden. Die Lösung dafür sind \enquote{Listener}.

\subsection{Listener}

Da wir mit einer interaktiven graphischen Oberfläche arbeiten, die in Abhängigkeit von einer Nutzerinteraktion (z.B. Klick auf den Button \enquote{Bold}) ihren Zustand verändert, müssen wir dafür sorgen, dass das Programm auf die Eingaben des Benutzer \textit{reagiert}. Um dies zu ermöglichen, benötigen wir sog. Listener--Klassen, die bei einer Interaktion eine bestimmte Methode aufrufen, in der wir festlegen, was passieren soll.

Jedes unserer interaktiven Toolbar Elemente (die Buttons und das DropDown--Menü) bekommen eine eigene Listener--Klasse, die jeweils eine Aktion ausführt, sobald ein Element angeklickt wurde.

Zur Implementierung der Listener gibt es verschiedene Möglichkeiten: Man könnte a) für jeden Button eine eigene Klasse anlegen, b) eine gemeinsame Listener--Klasse, die je nachdem welcher Button sie aufruft unterschiedliche Aktionen durchführt, oder c) jeweils anonyme innere Klasse als Listener erstellen.

In diesem Tutorial entscheiden wir uns für die letzte Möglichkeit, da diese uns ein paar Vorteile bietet. Welche das sind, sehen wir gleich. Schauen wir uns zuerst mal die Implementierung an:

  \begin{lstlisting}[frame=single,keywordstyle=\color{blue}]
 public class ToolbarPanel extends JPanel {
 	
//...
 	
 	private void setButtons(){
 	
 		toolbar.add(boldButton);
 		toolbar.add(italicButton);
 		toolbar.add(underlineButton);

 		boldButton.setIcon(new ImageIcon("src/img/font_bold_icon&32.png"));
 		italicButton.setIcon(new ImageIcon("src/img/font_italic_icon&32.png"));
 		underlineButton.setIcon(new ImageIcon("src/img/font_underline_icon&32.png"));
 		
 		boldButton.addItemListener(new ItemListener() {...});
  		italicButton.addItemListener(new ItemListener() {...});
  	 	underlineButton.addItemListener(new ItemListener() {...});
 	}
 	
 }
\end{lstlisting}

Mithilfe der Methode \lstinline[basicstyle=\ttfamily]{addItemListener(...)} wird einem Button ein neuer ItemListener hinzugefügt. Für die anonyme innere Klasse ist nichts weiter notwendig, als diese innerhalb der Methode zu definieren. Bisher tut unsere Klasse noch nichts, außer zu existieren. Indem wir aber eine odere mehrere ihrer Methoden überschreiben, können wir (Re-)Aktionen der Buttons definieren. 

  \begin{lstlisting}[frame=single,keywordstyle=\color{blue}]
 public class ToolbarPanel extends JPanel {
 	
//...
 	
 	private void setButtons(){
 	
	 	//...
 		
 		boldButton.addItemListener(new ItemListener() {
			
			@Override
			public void itemStateChanged(ItemEvent e) {
				//..
			}
			
 		});
 		//...
 	}
 	
 }
\end{lstlisting}

Wie im oben stehenden Code--Listing zu sehen, wird die Methode  \lstinline[basicstyle=\ttfamily]{itemStateChanged(ItemEvent e)} überschrieben. Die Methode wird immer dann aufgerufen, wenn ein Button geklickt und wieder losgelassen wurde. Über \lstinline[basicstyle=\ttfamily]{ItemEvent e} können wir nun feststellen, wie der aktuelle Status des \enquote{zugehörigen} Buttons ist.

  \begin{lstlisting}[frame=single,keywordstyle=\color{blue}]
 public class ToolbarPanel extends JPanel {
 
 	boolean bold;
 	
//...
 	
 	private void setButtons(){
 	
	 	//...
 		
 		boldButton.addItemListener(new ItemListener() {
			
			@Override
			public void itemStateChanged(ItemEvent e) {
				if(e.getStateChange()==e.SELECTED){
				bold = true;
				} else {
				bold = false;
				}
				this.updateAttributes();
			}
			
 		});
 		//...
 	}
 	
 	private void updateAttributes(){
 		//do some magic stuff here later
 	}
 	
 }
\end{lstlisting}

Möglich wird dies mit der Instanzmethode \lstinline[basicstyle=\ttfamily]{getStateChange()}, welche die Konstante \lstinline[basicstyle=\ttfamily]{SELECTED} zurückgibt, falls ein Button angeklickt ist. Dies kann für die anderen Buttons analog umgesetzt werden. In unserem Post-It speichern wir den aktuellen Zustand der Buttons in boolschen Variablen, um später darauf zugreifen zu können. Außerdem rufen wir, weil das später nötig sein wird, die Methode \lstinline[basicstyle=\ttfamily]{updateAttributes()} auf.

Die Implementierung für das Dropdown--Menü funktioniert analog: Zunächst wird ein Listener hinzugefügt und anschließend eine (bzw. mehrere) Methoden überschrieben. Der Unterschied besteht darin, dass diesmal ein Listener von Typ \lstinline[basicstyle=\ttfamily]{PopupMenuListener} verwendet werden muss, da ein Listener für JComboBox anders auf Eingaben reagieren muss. Dafür müssen die Abstrakten Methoden \lstinline[basicstyle=\ttfamily]{popupMenuWillBecomeVisible(PopupMenuEvent e)}, \lstinline[basicstyle=\ttfamily]{popupMenuWillBecomeInvisible(PopupMenuEvent e)} und  \lstinline[basicstyle=\ttfamily]{popupMenuCanceled(PopupMenuEvent e)} zwingend überschrieben werden. Für unseren Anwendungsfall interessiert aber nur \lstinline[basicstyle=\ttfamily]{popupMenuWillBecomeInvisible(PopupMenuEvent e)}. Sobald das DropDown-Menü geschlossen wurde, wollen wir nämlich die zuletzt ausgewählte Schriftart im String \lstinline[basicstyle=\ttfamily]{font} speichern.


  \begin{lstlisting}[frame=single,keywordstyle=\color{blue}]
 public class ToolbarPanel extends JPanel {
 
 	String[] fonts;
 	String font;
 	
//...
 	
private void setFontBox() {
		GraphicsEnvironment enviroment = GraphicsEnvironment.getLocalGraphicsEnvironment();
		fonts = enviroment.getAvailableFontFamilyNames();
		fontsComboBox = new JComboBox<String>(fonts);		
		fontsComboBox.addPopupMenuListener(new PopupMenuListener() {
			
			@Override
			public void popupMenuWillBecomeVisible(PopupMenuEvent e) {
			}
			
			@Override
			public void popupMenuWillBecomeInvisible(PopupMenuEvent e) {
				this.font = fontsComboBox.getSelectedItem().toString();
				this.updateAttributes();
			}
			
			@Override
			public void popupMenuCanceled(PopupMenuEvent e) {			
			}
		});
		
		fontsComboBox.setSelectedItem("Comic Sans MS");
	}

 	
 }
\end{lstlisting}

\subsection{Verknüpfung von Toolbar und Textpane}

Damit wir die Schriftart in JTextPane anpassen können, erstellen die Klasse \lstinline[basicstyle=\ttfamily]{NotesTextpane}, die JTextPane erweitert. 

 \begin{lstlisting}[frame=single,keywordstyle=\color{blue}]
 public class NotesTextPane extends JTextPane {
 
 }
 \end{lstlisting}

\subsection{TextSetting aktualisieren}

Mit einem Blick in die API von \lstinline[basicstyle=\ttfamily]{JTextPane} (die NotesTextPane erweitert), findet man die Methode setCharacterAttributes(...), die wie folgt beschrieben ist:

\subparagraph{public void setCharacterAttributes(AttributeSet attr,
                          boolean replace)}

Applies the given attributes to character content. If there is a selection, the attributes are applied to the selection range. If there is no selection, the attributes are applied to the input attribute set which defines the attributes for any new text that gets inserted.

Parameters:
\begin{itemize}
\item attr - the attributes
\item replace - if true, then replace the existing attributes first
\end{itemize}

Mit dieser Methode kann man die Attribute der Zeichen verändern, die man eintippt. Zusätzlich werden markierte Bereiche überschrieben. Das ist genau das was wir brauchen. Was wir jetzt noch brauchen ist ein \lstinline[basicstyle=\ttfamily]{AttributeSet}, das wir der Methode übergeben.

Da \lstinline[basicstyle=\ttfamily]{AttributeSet} jedoch lediglich ein Interface darstellt, das verbindlich festlegt welche Methoden und Felder implementiert werden müssen, ist es notwendig entweder eine eigene Klasse zu entwerfen, oder auf eine schon vorhandene Klasse zurückgreifen, die dieses Interface einbindet. Nach einem erneuten Blick in der API, findet man recht schnell eine Referenz auf die Klasse \lstinline[basicstyle=\ttfamily]{SimpleAttributeSet}.

Wir erstellen uns also eine neue Klasse \lstinline[basicstyle=\ttfamily]{NotesTextPane}, die von JTextPane erbt. Die Klasse besitzt das Feld \lstinline[basicstyle=\ttfamily]{currentAttributes} vom Typ \lstinline[basicstyle=\ttfamily]{SimpleAttributeSet} und eine Methode \lstinline[basicstyle=\ttfamily]{loadAttributes()}, die uns ein neues \lstinline[basicstyle=\ttfamily]{{SimpleAttributeSet} mit den von Anwender ausgewählten Einstellungen erstellt und anschließend auf den Text anwendet:

 \begin{lstlisting}[frame=single,keywordstyle=\color{blue}]
 public class NotesTextPane extends JTextPane {
 
 SimpleAttributeSet currentAttributes = new SimpleAttributeSet();

	public void loadAttributes() {
		this.setCharacterAttributes(currentAttributes, true);
	}
}
 \end{lstlisting}
 
Zusätzlich möchten wir aus unserer Klasse ToolbarPanel, die Methode loadAttributes aufrufen können und als Parameter die aktuelle Konfiguration unserer Buttons übergeben. 

Dafür sind zwei Dinge notwendig: Zum einen übergeben wir im Konstruktor von ToolBarPanel die aktuelle Instanz von NotesTextPane. Zweitens müssen wir die Methode loadAttributes um die entsprechenden Parameter erweitern und in unseren currentAttributes überschreiben.

 \begin{lstlisting}[frame=single,keywordstyle=\color{blue}]
 public class NotesTextPane extends JTextPane {
 
 	SimpleAttributeSet currentAttributes = new SimpleAttributeSet();
 
 	public void loadAttributes(boolean bold, boolean italic, boolean underlined, String font) {
	 	StyleConstants.setBold(currentAttributes,bold);
 		StyleConstants.setItalic(currentAttributes,italic));
 		StyleConstants.setUnderline(currentAttributes,underlined);
 		StyleConstants.setFontFamily(currentAttributes,font);
 		this.setCharacterAttributes(currentAttributes,true);
 	}	
 }
 \end{lstlisting}

Die Klasse ToolBarPanel erweitern wir wie folgt:

\begin{lstlisting}[frame=single,keywordstyle=\color{blue}]
  public class ToolbarPanel extends JPanel {
  
 //...
 NotesTextPane textpane;
  
  public ToolbarPanel(NotesTextPane ntp){
  
  textpane = ntp;
  toolbar = new JToolBar();
  this.setButtons();
  this.add(toolbar);
  
  }
  
  privat void updateAttributes(){
  	textpane.loadAttributes(bold,italic,underlined,fonts);
  }
}
  
\end{lstlisting}


unsere Frame--Klasse anpassen müssen. Die Klasse JTextPane, die bisher unsere Schreibfläche repräsentiert hat, muss jetzt durch die neue Klasse NotesTextPane ersetzt werden. Wir wechseln daher an dieser Stelle kurz zurück in die Klasse NotesFrame und nehmen folgende Änderungen vor:

  \begin{lstlisting}[frame=single,keywordstyle=\color{blue}]
  public class NotesFrame extends JFrame {
  
  JPanel mainPanel;
  ToolbarPanel toolbar;
  //JTextPane textpane; //alt! Zeile kann gelöscht werden...
  NotesTextPane textpane; //neu!
  
  public NotesFrame(){	
  
  this.mainPanel = new JPanel();
  //toolbar = new ToolbarPanel(); //alt! Zeile kann gelöscht werden...
  //textpane = new JtextPane(); //alt! Zeile kann gelöscht werden...
  textpane = new NotesTextPane(); //neu!
  toolbar = new ToolbarPanel(textpane); //neu!
  
  mainPanel.add(toolbar ,BorderLayout.PAGE_START);
  mainPanel.add(textpane,BorderLayout.CENTER);
  this.getcontentPane().add(mainPanel);
  
  pack();		
  this.setDefaultcloseOperation(EXIT_ON_CLOSE);
  }
  \end{lstlisting}
  
Achtung, nicht die Imports vergessen! 

\section{Fazit}

Unsere Anwendung befindet sich nun an einem Punkt, an dem man in den Testbetrieb wechseln könnte. Die Basis-Features sind implementiert und die im ersten Kapitel aufgestellten Anforderungen wurden umgesetzt: Wir haben eine Toolbar mit drei Buttons und einem Dropdown-Menü. Alle Änderungen, die wir auf der Toolbar auslösen, werden direkt im Textpane geladen.

Es gibt noch einige mögliche Features, die man umsetzen könnte, wie z.B. Laden- und Speichern von Nachrichten, wechselseitiges Laden zwischen Toolbar und Textpane und damit die Möglichkeit an Textbereichen mit gleicher Schriftart und -einstellung weiterschreiben kann.

Für dieses Tutorial ist der obenstehende Teil aber ausreichend, um einen kleinen Einblick in die Entwicklung einer graphischen Oberfläche und die Implementierung eines kleinen Editors zu erhalten.
\end{document}